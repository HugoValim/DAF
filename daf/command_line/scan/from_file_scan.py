#!/usr/bin/env python3

import argparse as ap
import numpy as np
import pandas as pd

from daf.utils.log import daf_log
from daf.command_line.cli_base_utils import CLIBase
from daf.command_line.scan.daf_scan_utils import ScanBase


class FromFileScan(ScanBase):

    DESC = """Perform a scan from a csv file generated by daf.scan"""
    EPI = """
    Eg:
        daf.ffscan my_scan -t 0.01

        """

    def __init__(self):
        super().__init__(scan_type="hkl")
        self.exp = self.build_exp()

    def parse_command_line(self):
        CLIBase.parse_command_line(self)
        self.parser.add_argument(
            "file_name", type=str, help="Perform a scan from the file generated by daf.scan"
        )
        self.common_cli_scan_arguments(step=False)
        args = self.parser.parse_args()
        return args

    def generate_data_for_scan(self, full_file_path: str, motor_map: dict) -> np.array:
        scan_points = pd.read_csv(full_file_path)
        mu_points = [float(i) for i in scan_points["Mu"]]  # Get only the points related to mu
        eta_points = [
            float(i) for i in scan_points["Eta"]
        ]  # Get only the points related to eta
        chi_points = [
            float(i) for i in scan_points["Chi"]
        ]  # Get only the points related to chi
        phi_points = [
            float(i) for i in scan_points["Phi"]
        ]  # Get only the points related to phi
        nu_points = [float(i) for i in scan_points["Nu"]]  # Get only the points related to nu
        del_points = [
            float(i) for i in scan_points["Del"]
        ]  # Get only the points related to del

        data_for_scan = {
            motor_map["mu"]: mu_points,
            motor_map["eta"]: eta_points,
            motor_map["chi"]: chi_points,
            motor_map["phi"]: phi_points,
            motor_map["nu"]: nu_points,
            motor_map["del"]: del_points,
        }
        ordered_motors = [i for i in data_for_scan.keys()]

        return data_for_scan, ordered_motors

    def configure_scan(self):
        data_for_scan, ordered_motors = self.generate_data_for_scan(self.parsed_args_dict['file_name'], self.motor_map)
        if self.parsed_args_dict['xlabel'] != None:
            xlabel = self.motor_map[self.parsed_args_dict['xlabel'].lower()]
        else:
            xlabel = "points"
        scan_args = self.config_scan_inputs(
            self.parsed_args_dict,
            self.motor_map,
            self.number_of_motors,
            self.scan_type,
            data_for_scan,
            ordered_motors,
            xlabel,
        )
        return scan_args

    def run_cmd(self, arguments):
        """
        Method to be defined be each subclass, this is the method
        that should be run when calling the cli interface
        """
        self.run_scan()


@daf_log
def main() -> None:
    obj = FromFileScan()
    obj.run_cmd(obj.parsed_args)


if __name__ == "__main__":
    main()














# #!/usr/bin/env python3


# import sys
# import os
# import subprocess

# import numpy as np
# import pandas as pd
# import yaml
# import argparse as ap
# import h5py

# # Py4Syn imports
# # import py4syn
# # from py4syn.utils import scan as scanModule
# # from py4syn.utils.scan import setFileWriter, getFileWriter, getOutput, createUniqueFileName

# # scan-utils imports
# # from scan_utils.hdf5_writer import HDF5Writer
# # from scan_utils import cleanup, die
# # from scan_utils import Configuration, processUserField, get_counters_in_config
# # from scan_utils.scan_pyqtgraph_plot import PlotScan
# # from scan_utils.scan_hdf_plot import PlotHDFScan
# from scan_utils import PlotType

# # from scan_utils import WriteType
# # from scan_utils import DefaultParser
# # from scan_utils.scan import ScanOperationCLI

# import daf
# import dafutilities as du
# import scan_daf as sd



# parser = ap.ArgumentParser(
#     formatter_class=ap.RawDescriptionHelpFormatter, description=__doc__, epilog=epi
# )
# parser.add_argument(
#     "file_name", type=str, help="Perform a scan from the file generated by daf.scan"
# )
# parser.add_argument(
#     "time",
#     metavar="time",
#     type=float,
#     help="Acquisition time in each point in seconds.",
# )
# parser.add_argument(
#     "-cf",
#     "--configuration",
#     type=str,
#     help="choose a counter configuration file",
#     default="default",
# )
# parser.add_argument(
#     "-o",
#     "--output",
#     help="output data to file output-prefix/<fileprefix>_nnnn",
#     default=os.getcwd() + "/scan_daf",
# )
# parser.add_argument(
#     "-s",
#     "--sync",
#     help="write to the output file after each point",
#     action="store_true",
# )
# parser.add_argument(
#     "-x",
#     "--xlabel",
#     help="motor which position is shown in x axis (if not set, point index is shown instead)",
#     default="points",
# )
# parser.add_argument(
#     "-sp",
#     "--show-plot",
#     help="Do not plot de scan",
#     action="store_const",
#     const=PlotType.hdf,
#     default=PlotType.none,
# )
# parser.add_argument(
#     "-cw",
#     "--close-window",
#     help="Close the scan window after it is done",
#     default=False,
#     action="store_true",
# )

# args = parser.parse_args()
# dic = vars(args)
# dict_args = du.read()
# du.log_macro(dict_args)

# scan_points = pd.read_csv(args.file_name)
# mu_points = [float(i) for i in scan_points["Mu"]]  # Get only the points related to mu
# eta_points = [
#     float(i) for i in scan_points["Eta"]
# ]  # Get only the points related to eta
# chi_points = [
#     float(i) for i in scan_points["Chi"]
# ]  # Get only the points related to chi
# phi_points = [
#     float(i) for i in scan_points["Phi"]
# ]  # Get only the points related to phi
# nu_points = [float(i) for i in scan_points["Nu"]]  # Get only the points related to nu
# del_points = [
#     float(i) for i in scan_points["Del"]
# ]  # Get only the points related to del

# if du.PV_PREFIX == "EMA:B:PB18":
#     data = {
#         "huber_mu": mu_points,
#         "huber_eta": eta_points,
#         "huber_chi": chi_points,
#         "huber_phi": phi_points,
#         "huber_nu": nu_points,
#         "huber_del": del_points,
#     }

#     xlabel_data = {
#         "mu": "huber_mu",
#         "eta": "huber_eta",
#         "chi": "huber_chi",
#         "phi": "huber_phi",
#         "nu": "huber_nu",
#         "del": "huber_del",
#     }

# else:
#     data = {
#         "sol_m3": mu_points,
#         "sol_m5": eta_points,
#         "sol_m2": chi_points,
#         "sol_m1": phi_points,
#         "sol_m4": nu_points,
#         "sol_m6": del_points,
#     }

#     xlabel_data = {
#         "mu": "sol_m3",
#         "eta": "sol_m5",
#         "chi": "sol_m2",
#         "phi": "sol_m1",
#         "nu": "sol_m4",
#         "del": "sol_m6",
#     }

# motors = [i for i in data.keys()]

# with open(".points.yaml", "w") as stream:
#     yaml.dump(data, stream, allow_unicode=False)

# if args.xlabel != "points":
#     xlabel = xlabel_data[args.xlabel.lower()]
# else:
#     xlabel = "points"

# args = {
#     "configuration": dict_args["default_counters"].split(".")[1],
#     "optimum": None,
#     "repeat": 1,
#     "sleep": 0,
#     "message": None,
#     "output": args.output,
#     "sync": True,
#     "snake": False,
#     "motor": motors,
#     "xlabel": xlabel,
#     "prescan": "ls",
#     "postscan": "pwd",
#     "plot_type": args.show_plot,
#     "relative": False,
#     "reset": False,
#     "step_mode": False,
#     "points_mode": False,
#     "start": None,
#     "end": None,
#     "step_or_points": None,
#     "time": [[args.time]],
#     "filename": ".points.yaml",
# }

# scan = sd.DAFScan(args, close_window=dic["close_window"])
# scan.run()
